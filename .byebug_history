exit
c
n
@record
exit
xit
exit
@thing
quit
continue
exit
Image.joins("left join Roles r on r.mname='Image' and r.mid=Images.id").select("Images.*, r.role_name").map {|img| img.attributes}
reload!
Image.joins("left join Roles r on r.mname='Image' and r.mid=Images.id").select("Images.*, r.role_name").map {|img| img.attributes}
Image.joins("join Roles r on r.mname='Image' and r.mid=Images.id").select("Images.*, r.role_name").map {|img| img.attributes}
Image.joins("join Roles r on r.mname='Image' and r.mid=Images.id").select("Images.*, r.role_name").first.attributes
Image.joins("join Roles r on r.mname='Image' and r.mid=Images.id").select("r.role_name").first.attributes
Image.joins("join Roles r on r.mname='Image' and r.mid=Images.id").select("r.role_name").attributes
Image.joins("join Roles r on r.mname='Image' and r.mid=Images.id").select("r.role_name")
Image.joins("join Roles r on r.mname='Image' and r.mid=Images.id")
Thing.all
Image.all
Role.where("mname='Image' and user_id=>10")
"
~
;
  "
"
Role.where("user_id=>10)
Role.where(:user_id=>10)
user
user = User.where(:uid=>"bolatan@bbunch.org").first
user
user = User.where(:uid=>"bolatan@bbunch.org")
reload!
alice.roles
alice = User.where(:email=>"alice@bbunch.org").first
exit
alice.roles
alice = User.where(:email=>"alice@bbunch.org").first
reload!
alice.roles
alice = User.where(:email=>"alice@bbunch.org").first
alice = User.where(:email=>/alice/).first
alice = User.where(:email=>/alice.+/).first
alice
alice = User.where(:email=>/alice.+/)
continue
"#{ui_path}"
ui_path
continue
next
path
exit
continue
next
exit
next
eite
x
.csc
cniucs.ll
cs
.l
otne
.rspec spec/features/authn*
.cls
.cld
continue
.rspec spec/features/authn*
.cls
.rails s
.cls
cls
User.all
User.delete_all
User.all
continue
page
continue
next
n
page.body
page.have_css? "Sign Up"
page.have_css? "button"
page.have_css?"button"
page
next
continue
next
continue
next
c
"#{ui_path}/#/signup"
ui_path
path
next
n
ui_path
exit
.exit
.cls
cls
Httparty
Httpparty
require 'Httparty'
cls
Httpparty
Httparty
exit
g.map {|a| a.except!(:notes, :description) }
g.except(:notes, :description)
.cls
g
.cls
g = (1..5).map { FactoryGirl.attributes_for(:thing) }
(1..5).map { FactoyGirl.attributes_for(:thing) }
(1..5).map { FactroyGirl.attributes_for(:thing) }
(1..5).inject({}) {|h, g| h[g] = "foo" }
(1..5).map { |a| {}[a] = "foo" }
(1..5).map { |a| {}.a = "foo" }
exit
cls
FactoryGirl.build(:thing, :with_notes_desc)
exit
cls
.rspec spec/requests/thin*
.cls
.rake routes
.rspec spec/models/thing*
.cls
cls
.rspec spec/models/thing*
.cls
.rspec spec/models/thing*
.rake db:migrate RAILS_ENV=test
.rspec spec/models/thing*
FactoryGirl.build(:thing, :with_description)
FactoryGirl.reload
FactoryGirl.build(:thing, :with_description)
FactoryGirl.build(:thing, :with_notes)
FactoryGirl.reload
FactoryGirl.build(:thing)
FactoryGirl.reload
FactoryGirl.build(:thing)
FactoryGirl.reload
FactoryGirl.build(:thing)
FactoryGirl.reload
FactoryGirl.build(:thing)
FactoryGirl.reload
FactoryGirl.build(:thing)
FactoryGirl.reload
FactoryGirl.build(:thing)
FActoryGirl.build(:thing)
exit
[1,2,3,4].inject({})
["access-token"].inject({}) {|h,k| h[k]=response[k]; h}
response = { "access-token"=>"Hello world"}
["access-tokens"].inject({}) {|h,k| h[k]=respo[k]; h}
exit
.cls
puts "Hello world" if: g
.irb
puts "Hello world", if: g
g = true
puts "Hello world", if: :true
puts "Hello world", if: true
end
  ;
puts "Hello world", if true
puts "Hello world"
if:
exit
(1..5).map {|b| City.create(name: "test#{b}")}
(1..5).map {|b| Foo.create(name: "test#{b}")}
(1..5).map {|b| Foo.create(name: "test#{b}"}
exit
.gitk --all
.git checkout testing
.git branch peer-review 6a87450
.git checkout testing
.git commit -am "finish"
.git add -A
.git checkout testing
.git commit -am "finish"
git commit -am "finish"
.git checkout testing
.bundle exec rspec -e "Create button disabled when no name"
.bundle exec rspec -e "invalid Foo reports API error"
reload!
.bundle exec rspec -e "invalid Foo reports API error"
.git am --signoff < ./0002-added-application-solutions.patch
.git am --signoff < ./0001-added-assignment-tests.patch
.git checkout testing-assignment
.bundle exec rspec -e "Create button disabled when no name"
.bundle exec rspec -e "invalid Foo reports API error"
bundle exec rspec -e "invalid Foo reports API error"
.cls
pp (1..11).map { FactoryGirl.build(:foo).name }
exit
.rspec
.rspec -e "Fooos create error"
.rspec
.rspec -e "Create button disabled when no name"
.cls
mkjdsbjkj
.cls
.rspec -e "Create button disabled when no name"
.rspec -e "Fooos create error"
.cls
exit
ls
error
continue
error
.rspec -e "Fooos create error"
reload!
f.errors.keys
f.errors.methods
f[:name]
f[:name].errors
f.errors.name.full_messages
f.errors.names.full_messages
f.errors.full_messages
f.errors.full_message
f.errors
f.name
f.errors
f
f = Foo.create()
reload!
.rspec -e "Fooos create error"
.rspec
pp (0..9).map { FactoryGirl.build(:foo).name};
pp (0..9).map { FactoryGirl.build(:foo)}.name;
FactoryGirl.reload
(0..9).map { FactoryGirl.build(:foo)}
FactoryGirl.reload
(0..9).map { FactoryGirl.build(:foo)}
FactoryGirl.reload
FactoryGirl.build(:foo)
FactoryGirl.reload
FactoryGirl.build(:foo)
FactoryGirl.reload
FactoryGirl.build(:foo)
FactoryGirl.reload
FactoryGirl.build(:foo)
FactoryGirl.reload
FactoryGirl.build(:foo)
FactoryGirl.reload
FactoryGirl.build(:foo)
